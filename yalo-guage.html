<link rel="import" href="../polymer/polymer.html">

<!--
Element providing solution to no problem in particular.

##### Example

    <yalo-guage></yalo-guage>

@element yalo-guage
@blurb Element providing solution to no problem in particular.
@status alpha
@homepage http://yalovek.github.io/yalo-guage
-->
<polymer-element name="yalo-guage" attributes="">
  <template>
    <link rel="stylesheet" href="yalo-guage.css">
    <svg id="guage" style="width: {{ width }}px; height: {{ height }}px;" viewBox="{{ viewBox }}" preserveAspectRatio="{{ preserveAspectRatio }}">
      <path d="{{ pathD }}" stroke="{{ stroke }}" stroke-width="{{ strokeWidth }}" fill="none"/>
      <circle fill="{{ fill }}" cx="{{ cx }}" cy="{{ cy }}" r="{{ dotR }}"/>
      <polygon fill="{{ fill }}" points="{{ arrowPoints }}"/>
    </svg>
  </template>
  <script>
    Polymer({
      width: 400,

      height: 350,

      viewBox: '0 0 400 350',

      preserveAspectRatio: 'xMidYMid meet',

      strokeWidth: 3,

      stroke: '#666',

      angle: 135,

      fill: '#3098e4',

      cx: 200,

      cy: 175,

      dotR: 9,

      value: 45,

      dotsFill: '#d9d9d9',

      scale: 61,

      divisionStorke: '#8c8c8c',

      ready: function () {
        this.viewBox = '0 0 ' + this.width + ' ' + this.height;

        this.arc();
        this.point();
        this.arrow();
        // this.dots();
        this.division();
      },

      arc: function () {
        var x = this.width / 2,
            y = this.height / 2,
            r = this.height / 2 - 50;

        this.pathD = this.describeArc(x, y, r, -this.angle, this.angle);
      },

      polarToCartesian: function (centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * Math.PI / 180;

        return {
          x: centerX + (radius * Math.cos(angleInRadians)),
          y: centerY + (radius * Math.sin(angleInRadians))
        };
      },

      describeArc: function (x, y, radius, startAngle, endAngle){
        var start = this.polarToCartesian(x, y, radius, endAngle),
            end = this.polarToCartesian(x, y, radius, startAngle),
            arcSweep = endAngle - startAngle <= 180 ? 0 : 1,
            d = [
              'M', start.x, start.y,
              'A', radius, radius, 0, arcSweep, 0, end.x, end.y
            ].join(' ');

        return d;
      },

      point: function () {
        var x = this.width / 2,
            y = this.height / 2;

        this.cx = x;
        this.cy = y;
      },

      arrow: function () {
        var x = this.width / 2,
            y = this.height / 2,
            r = this.height / 2 - 40,
            value = this.polarToCartesian(x, y, r, this.value),
            centerLeft = this.polarToCartesian(x, y, this.dotR / 2, this.value - 90),
            centerRight = this.polarToCartesian(x, y, this.dotR / 2, this.value + 90);

        this.arrowPoints = centerLeft.x + ',' + centerLeft.y + ' ' + value.x + ',' + value.y + ' ' + centerRight.x + ',' + centerRight.y;
      },

      dots: function () {
        var x = this.width / 2,
            y = this.height / 2,
            r = this.height / 2 - 40;

        for (var i = 0; i < this.scale; i++) {
          var svgns = "http://www.w3.org/2000/svg",
              circle = document.createElementNS(svgns, "circle"),
              dot = this.polarToCartesian(x, y, r, - this.angle + ((360 - ((360 - this.angle) - this.angle)) / (this.scale - 1)) * i);

          circle.setAttribute('fill', this.dotsFill);
          circle.setAttribute('cx', dot.x);
          circle.setAttribute('cy', dot.y);
          circle.setAttribute('r', 1);

          this.$.guage.appendChild(circle);
        }
      },

      division: function () {
        var x = this.width / 2,
            y = this.height / 2,
            r = this.height / 2 - 40,
            scale = ((this.division - 1) / 10) + 1;

        for (var i = 0; i < scale; i++) {
          var svgns = "http://www.w3.org/2000/svg",
              circle = document.createElementNS(svgns, "circle"),
              dot = this.polarToCartesian(x, y, r, - this.angle + ((360 - ((360 - this.angle) - this.angle)) / (scale - 1)) * i);

          circle.setAttribute('fill', this.divisionStorke);
          circle.setAttribute('cx', dot.x);
          circle.setAttribute('cy', dot.y);
          circle.setAttribute('r', 1);

          this.$.guage.appendChild(circle);
        }
      }
    });
  </script>
</polymer-element>
